#!/usr/bin/env zsh
source ~/.zsh/my_functions.zsh

function git:add:bulk {
  local files=( "${(@f)$( git:status:filter:unstaged:with_untracked )}" )

  if [ -n "${files[*]}" ]; then
    execute_with_echo    "git add --intent-to-add -- ${files[*]}"
    execute_with_echo    "git diff -- ${files[*]}"
    execute_with_confirm "git add -- ${files[*]}"
    execute_with_echo    "git status"
  fi
}

function git:add:bulk:intent {
  local files=( "${(@f)$( git:status:filter:untracked )}" )

  if [ -n "${files[*]}" ]; then
    execute_with_echo "git add --intent-to-add -- ${files[*]}"
    execute_with_echo "git status"
  fi
}

function git:add:bulk:patch {
  local files=( "${(@f)$( git:status:filter:unstaged:with_intended_to_add )}" )

  if [ -n "${files[*]}" ]; then
    execute_with_echo "git add --patch -- ${files[*]}"
    execute_with_echo "git status"
  fi
}

function git:restore:bulk {
  local files=( "${(@f)$( git:status:filter:unstaged )}" )

  if [ -n "${files[*]}" ]; then
    execute_with_echo    "git diff -R -- ${files[*]}"
    execute_with_confirm "git restore -- ${files[*]}"
    execute_with_echo    "git status"
  fi
}

function git:restore:bulk:staged {
  local files=( "${(@f)$( git:status:filter:staged )}" )

  if [ -n "${files[*]}" ]; then
    execute_with_echo    "git diff --staged -R -- ${files[*]}"
    execute_with_confirm "git restore --staged -- ${files[*]}"
    execute_with_echo    "git status"
  fi
}

function git:switch:select {
  local current="$( git branch --show-current )"
  local branch="$( git:branch:filter:one "^${current} +" )"

  [ -n "$branch" ] && execute_with_echo "git switch $branch"
}

function git:update:with_log {
  local remote_branch="$( git rev-parse --abbrev-ref '@{upstream}' )"

  execute_with_echo "git --no-pager show --no-patch"
  execute_with_echo "git fetch"

  if [ "$( git rev-parse HEAD )" = "$( git rev-parse '@{upstream}' )" ]; then
    echo "Up to date."
  else
    execute_with_echo "git --no-pager log --reverse HEAD.. ${remote_branch}"
    execute_with_echo "git pull --stat --rebase"
  fi
}

function git:update:shallow {
  execute_with_echo "git pull --rebase --depth 1"
}

function git:update:master {
  local current_branch="$( git branch --show-current )"

  execute_with_echo "git switch master"
  execute_with_echo "git update"
  execute_with_echo "git switch ${current_branch}"
}

function git:branch:create:with_set_upstream {
  local original_branch="$1"
  local branch_name="$2"
  local commit_message="$3"

  # shellcheck disable=SC2034
  local commands=(
    "git switch --create ${branch_name} ${original_branch}"
    "git commit --allow-empty --message=\"${commit_message}\""
    "git push --set-upstream origin ${branch_name}"
  )

  execute_with_confirm "${(j: && :)commands}; git branches"
}

function git:branch:delete:bulk:local {
  local filter_options=( --nth=1 --prompt="select branches: " --preview-window="down:50%:wrap:nohidden" --preview="git sh \"git:utility:preview:log {1}\"" )
  local branches=( "${(@f)$(
    git branch --verbose |
      grep -E -v "${GIT_PROTECTED_LOCAL_BRANCH_PATTERN}" |
      filter "${filter_options[@]}" |
      sed -e 's/^[* ]*//' |
      awk '{ print $1 }'
  )}" )

  if [ -n "${branches[*]}" ]; then
    execute_with_confirm "git branch --delete --force ${branches[*]}"
    execute_with_echo    "git branches"
  else
    echo "No target branches."
  fi
}

function git:branch:delete:bulk:remote {
  local filter_options=( --nth=1 --prompt="select branches: " --preview-window="down:50%:wrap:nohidden" --preview="git sh \"git:utility:preview:log {1}\"" )
  local branches=( "${(@f)$(
    git branch --verbose --remote |
      grep -E -v "${GIT_PROTECTED_REMOTE_BRANCH_PATTERN}" |
      filter "${filter_options[@]}" |
      awk '{ print $1 }' |
      sed -e 's#^origin/##'
  )}" )

  if [ -n "${branches[*]}" ]; then
    execute_with_confirm "git push --delete origin ${branches[*]}"
    execute_with_echo    "git branches"
  else
    echo "No target branches."
  fi
}

function git:branch:filter:one {
  local ignore_pattern="$1"
  local filter_options=( --no-multi --nth=1 --prompt="select a branch: " --preview-window="down:50%:wrap:nohidden" --preview="git sh \"git:utility:preview:log {1}\"" )
  local branches=( "${(@f)$( git:branch:all | grep -E -v "${ignore_pattern}" | filter "${filter_options[@]}" | awk '{ print $1 }' )}" )

  if [ ${#branches[@]} -ne 1 ] || [ -z "${branches[1]}" ]; then
    echo "Select a branch." >&2; exit 1
  else
    echo "${branches[1]}"
  fi
}

function git:branch:filter:remote:one {
  local prompt=${1:-"Select a branch: "}
  local filter_options=( --no-multi --nth=1 --prompt="${prompt}" --preview-window="down:50%:wrap:nohidden" --preview="git sh \"git:utility:preview:log {1}\"" )
  local branches=( "${(@f)$( git:branch:remote | filter "${filter_options[@]}" | awk '{ print $1 }' )}" )

  if [ ${#branches[@]} -ne 1 ] || [ -z "${branches[1]}" ]; then
    echo "Select only 1 branch." >&2; exit 1
  else
    echo "${branches[1]}"
  fi
}

function git:branch:all {
  local SEP="ðŸ’©"
  local list_format="%(refname:short)${SEP}%(objectname:short)${SEP}%(contents:subject)"

  git branch --all --format "${list_format}" |
    git:proxy:sed -e "s/\s*${SEP}\s*/${SEP}/g" -e 's/^origin\///' |
    grep -E -v "^HEAD${SEP}" |
    grep -E "^[a-zA-Z0-9]" |  # Remove branches with illegal characters
    column -t -s "$SEP" |
    awk '!x[$1]++'          # Remove duplicated branches
}

function git:branch:remote {
  git branch --remote --verbose | grep -E -v '^ *[^/]+/HEAD\b'
}

function git:clone:shallow {
  execute_with_echo "git clone --single-branch --depth 1 $*"
}

function git:clean:bulk {
  local files=( "${(@f)$( git:status:filter:untracked )}" )

  if [ -n "${files[*]}" ]; then
    git:proxy:cat:files "${files[@]}"
    execute_with_confirm "git clean --force -- ${files[*]}"
    execute_with_echo    "git status"
  fi
}

function git:log:compare:branch {
  local branch1=$( git:branch:filter:remote:one "select first branch: " )
  [ -n "$branch1" ] || exit 1

  local branch2=$( git:branch:filter:remote:one "select another branch: " )
  [ -n "$branch2" ] || exit 1

  execute_with_confirm "git log $* ${branch1}...${branch2}"
}

function git:diff:branch {
  local branch1=$( git:branch:filter:remote:one "select first branch: " )
  [ -n "$branch1" ] || exit 1

  local branch2=$( git:branch:filter:remote:one "select another branch: " )
  [ -n "$branch2" ] || exit 1

  execute_with_confirm "git diff-without-space-changes $* ${branch1}...${branch2}"
}

function git:diff:branch:from {
  local target="$1"

  if [ -n "$target" ]; then
    local current="$( git branch --show-current )"

    shift
    execute_with_confirm "git diff-without-space-changes $* origin/${target}...${current}"
  else
    echo "Specify a branch name, e.g., \"master\"." >&2; exit 1
  fi
}

function git:diff:branch:from:nameonly {
  local target="$1"

  if [ -n "$target" ]; then
    local current="$( git branch --show-current )"

    shift
    execute_with_confirm "git diff --name-only $* origin/${target}...${current}"
  else
    echo "Specify a branch name, e.g., \"master\"." >&2; exit 1
  fi
}

function git:stash:all:with_message {
  execute_with_confirm "git stash push --no-keep-index --include-untracked --message '$*'"
}

function git:status:filter:all {
  git status --short | git:status:utility:filter
}

function git:status:filter:staged {
  git status --short | grep -E '^[^ ?]|^ A' | git:status:utility:filter
}

function git:status:filter:unstaged {
  git status --short | grep -E '^[^?][^ A]' | git:status:utility:filter
}

function git:status:filter:unstaged:with_intended_to_add {
  git status --short | grep -E '^[^?][^ ]' | git:status:utility:filter
}

function git:status:filter:unstaged:with_untracked {
  git status --short | grep -E '^.[^ ]' | git:status:utility:filter
}

function git:status:filter:untracked {
  git status --short | grep -E '^\?\?' | git:status:utility:filter
}

function git:status:utility:filter {
  filter --prompt="Select files: " --preview-window="down:70%:wrap:nohidden" --preview="git diff-or-cat '{2..}'" | git:proxy:sed -e 's/^..\s//'
}

function git:submodule:update {
  execute_with_echo "git submodule update --remote --rebase"
  execute_with_echo "git status"
}

function git:submodule:remove:bulk {
  local targets=( "${(@f)$( git submodule | filter | awk '{ print $2 }' )}" )
  local target

  for target in "${targets[@]}"; do
    execute_with_confirm "git submodule deinit $target"
    execute_with_confirm "git rm $target"
    execute_with_confirm "trash $target"
  done
}

function git:submodule:deinit:bulk {
  local targets=( "${(@f)$( git submodule | filter | awk '{ print $2 }' )}" )
  local target

  for target in "${targets[@]}"; do
    execute_with_confirm "git submodule deinit -f $target"
    execute_with_confirm "rm -r ./git/modules/$target"
    execute_with_confirm "trash $target/*"
    execute_with_confirm "trash $target/.*"
  done
}

function git:alias:list {
  git config --get-regexp '^alias\.' |
    git:proxy:sed -e 's/alias\.\([^ ]*\) \(.*\)/\1\t => \2/'
}

function git:utility:chmod {
  execute_with_echo "git update-index --add --chmod=$1"
}

function git:utility:diff_or_cat {
  local filepath="$1"
  local git_status="$( git status --short -- "$filepath" )"

  # Untracked files
  if [[ "$git_status" =~ '^\?\?' ]]; then
    git:proxy:cat:files "$filepath"
  # Staged files
  elif [[ "$git_status" =~ ^[A-Z] ]]; then
    git diff-without-space-changes --color=always --staged -- "$filepath"
  # Others: unstaged tracked files
  else
    git diff-without-space-changes --color=always -- "$filepath"
  fi
}

function git:utility:cat {
  git:proxy:cat:files "$@"
}

function git:utility:preview:log {
  local branch="$1"

  if ! git branch --contains "$branch" > /dev/null 2>&1; then
    branch="origin/$branch"
  fi

  git log --max-count=100 --color=always "$branch"
}

function git:proxy:sed {
  if command -v gsed > /dev/null; then
    gsed "$@"
  else
    sed "$@"
  fi
}

function git:proxy:wc {
  if command -v gwc > /dev/null; then
    gwc "$@"
  else
    wc "$@"
  fi
}

function git:proxy:cat:files {
  local filepath
  local filepaths=( "$@" )

  if [ -z "${filepaths[*]}" ]; then
    return 1
  fi

  local realpaths=()

  for filepath in "${filepaths[@]}"; do
    realpaths+=( "${filepath/\~/$HOME}" )
  done

  if command -v bat > /dev/null; then
    bat --wrap --color=always --style=full "${realpaths[@]}"
  else
    for filepath in "${realpaths[@]}"; do
      printf "\n** File: %s\n\n" "${filepath}"
      cat "${filepath}"
      echo
    done
  fi
}
